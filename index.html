
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapa Interativo Avançado</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    #map{position:absolute;top:0;left:300px;right:0;bottom:0}
    #sidebar{position:absolute;left:0;top:0;bottom:0;width:300px;overflow:auto;background:#fff;padding:12px;box-shadow:2px 0 6px rgba(0,0,0,0.15);z-index:400}
    .item{padding:8px;border-bottom:1px solid #eee;cursor:pointer}
    .filters{margin-bottom:12px}
    .legend {display:flex;flex-wrap:wrap;gap:6px}
    .legend .chip{padding:6px 8px;border-radius:6px;color:#fff;font-size:13px}
    #searchInput{width:100%;padding:8px;margin-bottom:8px}
    .btn{display:inline-block;padding:6px 10px;background:#2b7cff;color:#fff;border-radius:6px;text-decoration:none}
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Mapeamento Cultural</h3>
    <input id="searchInput" placeholder="Pesquisar por nome, cidade, atividade..." />
    <div class="filters">
      <div><strong>Filtros</strong></div>
      <div id="filterTipo"></div>
      <div style="margin-top:8px"><strong>Legenda (Tipo de atividade)</strong></div>
      <div id="legend" class="legend"></div>
    </div>
    <div style="margin-top:8px">
      <a id="geocodeAll" class="btn">Geocodificar todos (Risco: lento)</a>
      <a id="resetView" class="btn" style="background:#444;margin-left:8px">Resetar</a>
    </div>
    <hr/>
    <div id="list"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script>
    const map = L.map('map').setView([-15.8, -47.9], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // Globals
    let geoData;
    let markers = L.markerClusterGroup();
    const typeColors = {}; // will map tipo->color
    const activeFilters = new Set();

    // Utility: random pastel color by string
    function colorByString(s){
      // deterministic hash
      let h=0; for(let i=0;i<s.length;i++) h = s.charCodeAt(i) + ((h<<5)-h);
      const c = (h & 0x00FFFFFF).toString(16).toUpperCase();
      return '#'+('00000'.substring(0,6-c.length)+c);
    }

    // Load GeoJSON
    fetch('mapeamento.geojson').then(r=>r.json()).then(data=>{
      geoData = data;
      prepareTypes();
      populateSidebar();
      addAllMarkers();
    });

    function prepareTypes(){
      const types = new Set();
      geoData.features.forEach(f=>{
        const t = (f.properties && f.properties['TIPO DE ATIVIDADE']) || 'Sem Tipo';
        types.add(t);
      });
      // build legend and filter checkboxes
      const legend = document.getElementById('legend');
      const filterDiv = document.getElementById('filterTipo');
      Array.from(types).sort().forEach(t=>{
        const color = colorByString(t);
        typeColors[t]=color;
        const chip = document.createElement('div');
        chip.className='chip';
        chip.style.background = color;
        chip.textContent = t;
        legend.appendChild(chip);

        const id = 'chk_'+t.replace(/\W/g,'_');
        const label = document.createElement('label');
        label.style.display='block';
        label.innerHTML = `<input type="checkbox" id="${id}" checked /> ${t}`;
        filterDiv.appendChild(label);
        document.getElementById(id).addEventListener('change', (e)=>{
          if(e.target.checked) activeFilters.delete(t); else activeFilters.add(t);
          refreshMarkers();
        });
      });
    }

    function createMarker(feature){
      const p = feature.properties || {};
      if(!feature.geometry || feature.geometry.type !== 'Point' || !feature.geometry.coordinates){
        return null;
      }
      const [lng,lat]=feature.geometry.coordinates;
      const tipo = p['TIPO DE ATIVIDADE'] || 'Sem Tipo';
      const color = typeColors[tipo] || '#333';
      const icon = L.divIcon({
        html: `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="36"><path d="M14 0C8 0 4 4.8 4 9.8 4 17.6 14 36 14 36s10-18.4 10-26.2C24 4.8 20 0 14 0z" fill="${color}"/></svg>`,
        className:'',
        iconSize:[28,36],
        iconAnchor:[14,36],
      });
      const m = L.marker([lat,lng], {icon: icon});
      const html = `<strong>${p['COLETIVO/NOME'] || p['PESSOA/COLETIVO'] || 'Sem nome'}</strong><br/>
                    <small>${tipo} — ${p['TERRITÓRIO'] || ''}</small><hr/>
                    <div><b>Cidade:</b> ${p['CIDADE']||''} - ${p['ESTADO']||''}</div>
                    <div><b>Contato:</b> ${p['WHATSAPP']||p['TELEFONE']||''}</div>
                    <div><b>Redes:</b> ${p['INSTAGRAM']||p['FACEBOOK']||''}</div>`;
      m.bindPopup(html);
      m.feature = feature; // attach ref
      return m;
    }

    function addAllMarkers(){
      markers.clearLayers();
      geoData.features.forEach(f=>{
        const m = createMarker(f);
        if(m) markers.addLayer(m);
      });
      map.addLayer(markers);
      if(markers.getLayers().length) map.fitBounds(markers.getBounds(), {maxZoom:12});
    }

    function refreshMarkers(){
      markers.clearLayers();
      geoData.features.forEach(f=>{
        const tipo = (f.properties && f.properties['TIPO DE ATIVIDADE']) || 'Sem Tipo';
        if(activeFilters.has(tipo)) return; // filtered out
        const m = createMarker(f);
        if(m) markers.addLayer(m);
      });
      if(markers.getLayers().length) map.fitBounds(markers.getBounds(), {maxZoom:12});
    }

    // Sidebar listing and click-to-zoom
    function populateSidebar(){
      const list = document.getElementById('list');
      list.innerHTML='';
      geoData.features.forEach((f, idx)=>{
        const p = f.properties || {};
        const div = document.createElement('div');
        div.className='item';
        div.innerHTML = `<strong>${p['COLETIVO/NOME'] || p['PESSOA/COLETIVO'] || 'Sem nome'}</strong><div style="font-size:13px">${p['CIDADE']||''} - ${p['ESTADO']||''} <small style="color:#666">(${p['TIPO DE ATIVIDADE']||''})</small></div>`;
        div.addEventListener('click', ()=>{
          if(f.geometry && f.geometry.coordinates){
            const [lng,lat]=f.geometry.coordinates;
            map.setView([lat,lng], 14);
            // open popup: find marker
            markers.eachLayer(layer=>{
              if(layer.feature === f){ layer.openPopup(); }
            });
          } else {
            // try to geocode on demand
            geocodeFeature(f).then(success=>{
              if(success){
                populateSidebar(); refreshMarkers();
                const [lng,lat]=f.geometry.coordinates;
                map.setView([lat,lng], 14);
                markers.eachLayer(layer=>{ if(layer.feature===f) layer.openPopup(); });
              } else {
                alert('Localização não encontrada para este registro.');
              }
            });
          }
        });
        list.appendChild(div);
      });
    }

    // SEARCH - substitua o handler antigo por este para geocodificar itens encontrados sem coords
document.getElementById('searchInput').addEventListener('keyup', async (e) => {
  const q = e.target.value.trim().toLowerCase();
  const list = document.getElementById('list');
  const items = Array.from(list.querySelectorAll('.item'));

  // feedback visual simples
  const searchInput = document.getElementById('searchInput');
  let originalPlaceholder = searchInput.placeholder;
  if(q) {
    searchInput.placeholder = 'Pesquisando e geocodificando (se necessário)...';
    searchInput.disabled = true;
  }

  // encontra índices de features que batem com a query
  const matchedIndices = [];
  items.forEach((it, i) => {
    const f = geoData.features[i];
    const txt = JSON.stringify(f.properties || {}).toLowerCase();
    if(!q || txt.includes(q)) {
      it.style.display = 'block';
      matchedIndices.push(i);
    } else {
      it.style.display = 'none';
    }
  });

  // Para cada item que bateu e não tem geometry, tentar geocodificar (com delay)
  if(q && matchedIndices.length) {
    for (let idx of matchedIndices) {
      const f = geoData.features[idx];
      if (!f.geometry || !f.geometry.coordinates) {
        // tenta geocodificar, com delay para respeitar limites
        const ok = await geocodeFeature(f);
        await new Promise(r => setTimeout(r, 1200)); // 1.2s entre chamadas
        // se geocodificou com sucesso, atualizamos a lista item visível e os marcadores
        if (ok) {
          // atualizar sidebar item (para evitar re-render completo)
          // re-criamos a lista inteira para manter consistência
          populateSidebar();
          refreshMarkers();
        }
      }
    }
  }

  // após geocodificação, atualiza marcadores (caso novas coords apareçam)
  refreshMarkers();

  // desbloquear input e restaurar placeholder
  searchInput.disabled = false;
  searchInput.placeholder = originalPlaceholder;
});


    // Geocoding (lazy, using Nominatim, with caching in localStorage)
    async function geocodeFeature(f){
      const p = f.properties || {};
      const query = `${p['COLETIVO/NOME']||''}, ${p['CIDADE']||''}, ${p['ESTADO']||''}`;
      const cacheKey = 'geo_cache_'+encodeURIComponent(query);
      const cached = localStorage.getItem(cacheKey);
      if(cached){
        const [lat,lon] = cached.split(',');
        f.geometry = {type:'Point', coordinates:[parseFloat(lon), parseFloat(lat)]};
        return true;
      }
      // call nominatim
      try{
        const url = 'https://nominatim.openstreetmap.org/search?format=json&q='+encodeURIComponent(query)+'&limit=1';
        const resp = await fetch(url, {headers:{'Accept-Language':'pt'}, method:'GET'});
        if(!resp.ok) return false;
        const j = await resp.json();
        if(j && j.length){
          const lat = parseFloat(j[0].lat), lon = parseFloat(j[0].lon);
          f.geometry = {type:'Point', coordinates:[lon, lat]};
          localStorage.setItem(cacheKey, lat+','+lon);
          return true;
        }
        return false;
      }catch(e){
        console.error(e); return false;
      }
    }

    // Geocode all button (with delay)
    document.getElementById('geocodeAll').addEventListener('click', async ()=>{
      if(!confirm('Isto fará muitas requisições ao Nominatim. Pode ser lento e sujeito a limites. Continuar?')) return;
      for(let i=0;i<geoData.features.length;i++){
        const f = geoData.features[i];
        if(!f.geometry || !f.geometry.coordinates){
          await geocodeFeature(f);
          await new Promise(r=>setTimeout(r, 1200)); // respect rate limit
        }
      }
      // after geocoding, refresh markers and sidebar
      populateSidebar();
      refreshMarkers();
      alert('Geocodificação tentativa finalizada. Confira os pontos no mapa.');
    });

    document.getElementById('resetView').addEventListener('click', ()=>{
      if(markers.getLayers().length) map.fitBounds(markers.getBounds(), {maxZoom:12});
    });

    // Zoom to category on legend click
    document.getElementById('legend').addEventListener('click', (e)=>{
      const chip = e.target;
      if(!chip.classList.contains('chip')) return;
      const tipo = chip.textContent;
      // zoom to bounds of that tipo
      const latlngs = [];
      geoData.features.forEach(f=>{
        if((f.properties && f.properties['TIPO DE ATIVIDADE'])===tipo && f.geometry && f.geometry.coordinates){
          const [lng,lat]=f.geometry.coordinates; latlngs.push([lat,lng]);
        }
      });
      if(latlngs.length) map.fitBounds(latlngs, {maxZoom:12});
      else alert('Ainda não há coordenadas para essa categoria. Clique em um item para geocodificar ou use "Geocodificar todos".');
    });

  </script>
</body>
</html>
